#!/bin/bash

# DESCRIPTION
# This script is necessary because kubernetes doesn't
# set the pod hostname to a hostname that's resolvable
# outside of the pod.

# Kubernetes does however assign pod hostnames that are
# resolvable from others pods, and the algorithm is
# simple enough.

# When eval'd or executed, this script links the
# /usr/local/bin/kube-hostname-wrapper script to a
# directory in the beginning of the path, under ~ for
# the purposes of wrapping the hostname binary.

# Afterwards, it sets the HOSTNAME environment variable
# to shortname or longname (fqdn), defaulting to fqdn.

# It also echo's the hostname's short and longname to
# the /etc/hosts file for both localIP and podIP.

# Finally HOSTNAME is exported so that the current
# and any subshell just works, this only works if
# executing script inside an eval.  Ex:
#   eval $(kube-fix-hostname {enable|disable})

# ARGUMENTS
# n/a

KHF_BASE=$(basename $0)
KHF_DIR=$(dirname $0)
KHF_WRAP_PATH="$KHF_DIR/kube-hostname-wrapper"
KHF_NAME="Kubernetes Hostname-Fix"


function link-hostname {
    [[ ! $- =~ i ]] && echo "Applying $KHF_NAME ..." >&2
    # ln -sf $KHF_DIR/kube-hostname-wrapper $KHF_DIR/hostname
    if [[ ! $PATH =~ $KHF_WRAP_PATH ]]; then
        echo "OLDPATH=$PATH"
        echo "PATH=${KHF_WRAP_PATH}:$PATH"
    fi
}

function unlink-hostname {
    [[ ! $- =~ i ]] && echo "Unapplying $KHF_NAME ..." >&2
    # [ -f $KHF_DIR/hostname ] && rm -f $KHF_DIR/hostname
    if [[ ! $PATH =~ $KHF_WRAP_PATH ]]; then
        if [[ ! -z $OLDPATH ]]; then
            echo "PATH=$OLDPATH"
        else
            echo "PATH=${PATH//$KHF_WRAP_PATH:/}"
        fi
    fi
}

function hash-hostname {
    hash -r
}

function set-hostname-env {
    if [ "$KUBE_HOSTNAME_SHORT" = true ]; then
        HOSTNAME=$(env hostname -s)
    else
        HOSTNAME=$(env hostname -f)
    fi
}

function set-etc-hostname {
    echo "$HOSTNAME" > /etc/hostname
}

function write-etc-hosts {
    local ip=$(env hostname -i)
    local short=$(env hostname -s)
    local fqdn=$(env hostname -f)
    clean-etc-hosts
    if ! cat /etc/hosts | grep --silent $HOSTNAME; then
        cat <<EOF >> /etc/hosts
127.0.0.1    $fqdn    $short   # added by $KHF_BASE
$ip    $fqdn    $short # added by $KHF_BASE
EOF
    fi
}

function clean-etc-hosts {
    # it's really hard writing to the mounted file /etc/hosts
    # correctly under docker.
    echo "$(sed "/$KHF_BASE/d" /etc/hosts)" > /etc/hosts
}

function export-hostname {
    echo "HOSTNAME=$HOSTNAME"
}

function enable {
    link-hostname
    hash-hostname
    set-hostname-env
    set-etc-hostname
    write-etc-hosts
    export-hostname
}

function disable {
    unlink-hostname
    hash-hostname
    set-hostname-env
    set-etc-hostname
    clean-etc-hosts
    export-hostname
}

if [ "$1" ]; then
    "$@"
else
    echo "usage: export \$($KHF_BASE {enable|disable})" >&2
    exit 1
fi
