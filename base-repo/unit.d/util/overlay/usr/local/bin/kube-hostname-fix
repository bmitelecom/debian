#!/bin/bash

# DESCRIPTION
# This script is necessary because kubernetes doesn't
# set the pod hostname to a hostname that's resolvable
# outside of the pod.

# Kubernetes does however assign pod hostnames that are
# resolvable from others pods, and the algorithm is
# simple enough.

# When eval'd or executed, this script links the
# /usr/local/bin/kube-hostname-wrapper script to a
# directory in the beginning of the path, under ~ for
# the purposes of wrapping the hostname binary.

# Afterwards, it sets the HOSTNAME environment variable
# to shortname or longname (fqdn), defaulting to fqdn.

# It also echo's the hostname's short and longname to
# the /etc/hosts file for both localIP and podIP.

# Finally HOSTNAME is exported so that the current
# and any subshell just works, this only works if
# executing script inside an eval.  Ex:
#   export $(kube-fix-hostname {enable|disable})

# ARGUMENTS
# action:
#   `enable` or `disable`, required.


base=$(basename $0)
LIB_OVERRIDEHOSTNAME_PATH=/usr/local/lib/liboverridehostname.so.1

# Helpers

function get-ip {
    hostname -I | xargs -n 1 | head -1
}

function get-namespace {
    if [[ -f /var/run/secrets/kubernetes.io/serviceaccount/namespace ]]; then
        echo $(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
    else
        echo "${NAMESPACE:=default}"
    fi
}

function get-domain {
    echo "${NAMESPACE:-cluster.local}"
}

function get-shost {
    get-ip | sed 's/\./-/g'
}

function get-fqdn {
    local ip=$(get-ip)
    local shost=$(get-shost)
    local namespace=$(get-namespace)
    local domain=$(get-domain)
    echo "${shost}.${namespace}.pod.${domain}"
}

function get-hostname {
    if [[ $USE_LONG_HOSTNAME == true ]]; then
        get-fqdn
    else
        get-shost
    fi
}

function get-orig-hostname {
    uname -n
}

# Actions

function load-module {
    export LD_PRELOAD=$LIB_OVERRIDEHOSTNAME_PATH
    export OVERRIDE_HOSTNAME=true
    echo "export LD_PRELOAD=$LIB_OVERRIDEHOSTNAME_PATH"
    echo "export OVERRIDE_HOSTNAME=true"
}

function unload-module {
    unset LD_PRELOAD OVERRIDE_HOSTNAME
    echo "unset LD_PRELOAD OVERRIDE_HOSTNAME"
}

function set-hostname {
    hostname "$(get-hostname)"
}

function unset-hostname {
    hostname "$(get-orig-hostname)"
}

function set-hostname-env {
    export HOSTNAME=$(hostname)
    echo "export HOSTNAME=$(hostname)"
}

function unset-hostname-env {
    export HOSTNAME=$(get-orig-hostname)
    echo "export HOSTNAME=$(get-orig-hostname)"
}

function write-new-to-etc-hosts {
    local ip=$(get-ip)
    local shost=$(get-shost)
    local fqdn=$(get-fqdn)
    if ! cat /etc/hosts | grep --silent "$shost"; then
        echo "$ip    $fqdn  $shost" >> /etc/hosts
    fi
}

function write-orig-to-etc-hosts {
    local ip=$(get-ip)
    local ohost=$(get-orig-hostname)
    if ! cat /etc/hosts | grep --silent "$ohost"; then
        echo "$ip    $ohost" >> /etc/hosts
    fi
}

function remove-orig-from-etc-hosts {
    # it's really hard writing to the mounted file /etc/hosts
    # correctly under docker.
    echo "$(sed "/$(get-orig-hostname)/d" /etc/hosts)" > /etc/hosts
}

function remove-override-from-etc-hosts {
    # it's really hard writing to the mounted file /etc/hosts
    # correctly under docker.
    echo "$(sed "/$(get-shost)/d" /etc/hosts)" > /etc/hosts
}

# Targets

function enable {
    load-module
    set-hostname
    remove-orig-from-etc-hosts
    write-new-to-etc-hosts
    set-hostname-env
}

function disable {
    unset-hostname
    remove-override-from-etc-hosts
    write-orig-to-etc-hosts
    unset-hostname-env
    unload-module
}

if [ "$1" ]; then
    "$@"
else
    echo "usage: export \$($base {enable|disable})" >&2
    exit 1
fi
